package edu.uky.cs.nil.sabre.search;

import java.io.Serializable;

import edu.uky.cs.nil.sabre.Action;
import edu.uky.cs.nil.sabre.Main;
import edu.uky.cs.nil.sabre.Plan;
import edu.uky.cs.nil.sabre.Problem;
import edu.uky.cs.nil.sabre.Settings;
import edu.uky.cs.nil.sabre.util.Worker.Status;

/**
 * A planner is a configurable factory object for producing {@link Search
 * searches} that solve {@link Problem planning problems} by generating {@link
 * Plan plans}. A planner assumes that the space of possible solutions can be
 * represented as a graph such that counting the numbers of nodes visited and
 * generated by the search is a meaningful way to measure the amount of work
 * done by the planner. Different planning approaches may vary in what they
 * define as a node and how much work is required to visit or generate a node.
 * 
 * @param <A> the type of {@link Action action} used in solution plans this
 * planner's {@link Search searches} produce
 * @author Stephen G. Ware
 */
public abstract class Planner<A extends Action> implements Serializable {
	
	/** The constant used to represent no limit on a number of nodes */
	public static final long UNLIMITED_NODES = 0;
	
	/** The constant used to represent no limit on an amount of time */
	public static final long UNLIMITED_TIME = 0;
	
	/**
	 * The constant used to represent no limit on the {@link
	 * Search#authorTemporalLimit author} and {@link
	 * Search#characterTemporalLimit character temporal depths} and the {@link
	 * Search#epistemicLimit epistemic depth} or a search
	 */
	public static final int UNLIMITED_DEPTH = -1;
	
	/** Serial version ID */
	private static final long serialVersionUID = Settings.VERSION_UID;
	
	/** The name of the planner */
	public final String name;
	
	/** The {@link Search#searchLimit limit on nodes visited} */
	private long searchLimit = UNLIMITED_NODES;
	
	/** The {@link Search#spaceLimit limit on nodes generated} */
	private long spaceLimit = UNLIMITED_NODES;
	
	/** The {@link Search#timeLimit limit on time spent} */
	private long timeLimit = UNLIMITED_TIME;
	
	/**
	 * The {@link Search#authorTemporalLimit limit on number of actions in the
	 * author's plan}
	 */
	private int authorTemporalLimit = UNLIMITED_DEPTH;
	
	/**
	 * The {@link Search#characterTemporalLimit limit on number of actions in a
	 * character's plan}
	 */
	private int characterTemporalLimit = UNLIMITED_DEPTH;
	
	/**
	 * The {@link Search#epistemicLimit limit on how deeply theory of mind can
	 * be searched}
	 */
	private int epistemicLimit = UNLIMITED_DEPTH;
	
	/**
	 * Constructs a new planner with the given name.
	 * 
	 * @param name the name of the planner
	 */
	public Planner(String name) {
		this.name = name;
	}
	
	@Override
	public String toString() {
		return "[" + toString(name) + "]";
	}
	
	/**
	 * Returns a string composed of a name and a description of the planner's
	 * settings, primary for use in {@link #toString()}.
	 * 
	 * @param name the name of the planner
	 * @return a string of the name and planner's settings
	 */
	protected String toString(String name) {
		String string = name + ": ";
		string += Main.SEARCH_LIMIT_KEY.substring(1) + "=" + getSearchLimit();
		string += "; sl=" + getSpaceLimit();
		string += "; tl=" + getTimeLimit();
		string += "; atl=" + getAuthorTemporalLimit();
		string += "; ctl=" + getCharacterTemporalLimit();
		string += "; el=" + getEpistemicLimit();
		return string;
	}
	
	/**
	 * Returns the maximum number of nodes that a {@link Search search} may
	 * visit when {@link Search#get(Status) searching for a solution}. Visiting
	 * a node generally means considering it and expanding its children nodes,
	 * if any. The constant {@link #UNLIMITED_NODES} indicates no limit on how
	 * many nodes may be visited.
	 * 
	 * @return the max number of nodes to visit
	 */
	public long getSearchLimit() {
		return searchLimit;
	}
	
	/**
	 * Sets the maximum number of nodes that a {@link Search search} may visit
	 * when {@link Search#get(Status) searching for a solution}. Visiting a
	 * node generally means considering it and expanding its children nodes, if
	 * any. The constant {@link #UNLIMITED_NODES} may be used to impose no
	 * limit on how many nodes may be visited.
	 * 
	 * @param limit the new max number of nodes to visit
	 */
	public void setSearchLimit(long limit) {
		this.searchLimit = Math.max(limit, UNLIMITED_NODES);
	}
	
	/**
	 * Returns the maximum number of nodes that a {@link Search search} may
	 * generate while {@link Search#get(Status) searching for a solution}. The
	 * number of generated nodes counts all nodes ever created during the
	 * search for any purpose, regardless of whether they were ever visited.
	 * The constant {@link #UNLIMITED_NODES} indicates no limit on how many
	 * nodes may be generated.
	 * 
	 * @return the max number of nodes to generate
	 */
	public long getSpaceLimit() {
		return spaceLimit;
	}
	
	/**
	 * Sets the maximum number of nodes that a {@link Search search} may
	 * generate while {@link Search#get(Status) searching for a solution}. The
	 * number of generated nodes counts all nodes ever created during the
	 * search for any purpose, regardless of whether they were ever visited.
	 * The constant {@link #UNLIMITED_NODES} may be used to impose no limit on
	 * how many nodes may be generated.
	 * 
	 * @param limit the new max number of nodes to generate
	 */
	public void setSpaceLimit(long limit) {
		this.spaceLimit = Math.max(limit, UNLIMITED_NODES);
	}
	
	/**
	 * Returns the maximum number of milliseconds which may elapse while {@link
	 * Search#get(Status) searching for a solution}. The constant {@link
	 * #UNLIMITED_TIME} indicates no limit on the amount of time that may be
	 * taken.
	 * 
	 * @return the max number of milliseconds to search
	 */
	public long getTimeLimit() {
		return timeLimit;
	}
	
	/**
	 * Sets the maximum number of milliseconds which may elapse while {@link
	 * Search#get(Status) searching for a solution}. The constant {@link
	 * #UNLIMITED_TIME} may be used to impose no limit on the amount of time
	 * that may be taken.
	 * 
	 * @param limit the new max number of milliseconds to search
	 */
	public void setTimeLimit(long limit) {
		this.timeLimit = Math.max(limit, UNLIMITED_TIME);
	}
	
	/**
	 * Returns the {@link Search#authorTemporalLimit author temporal limit} for
	 * any {@link Search searches} created by this planner. The constant {@link
	 * #UNLIMITED_DEPTH} represents no limit.
	 * 
	 * @return the author temporal limit, or {@link #UNLIMITED_DEPTH} if there
	 * is no limit
	 */
	public int getAuthorTemporalLimit() {
		return authorTemporalLimit;
	}
	
	/**
	 * Sets the {@link Search#authorTemporalLimit author temporal limit} for any
	 * {@link Search searches} created by this planner. The constant {@link
	 * #UNLIMITED_DEPTH} represents no limit.
	 * 
	 * @param limit the author temporal limit, or {@link #UNLIMITED_DEPTH} if
	 * there should be no limit
	 */
	public void setAuthorTemporalLimit(int limit) {
		this.authorTemporalLimit = limit;
	}
	
	/**
	 * Returns the {@link Search#characterTemporalLimit character temporal
	 * limit} for any {@link Search searches} created by this planner. The
	 * constant {@link #UNLIMITED_DEPTH} represents no limit.
	 * 
	 * @return the character temporal limit, or {@link #UNLIMITED_DEPTH} if
	 * there is no limit
	 */
	public int getCharacterTemporalLimit() {
		return characterTemporalLimit;
	}
	
	/**
	 * Sets the {@link Search#characterTemporalLimit character temporal limit}
	 * for any {@link Search searches} created by this planner. The constant
	 * {@link #UNLIMITED_DEPTH} represents no limit.
	 * 
	 * @param limit the character temporal limit, or {@link #UNLIMITED_DEPTH} if
	 * there should be no limit
	 */
	public void setCharacterTemporalLimit(int limit) {
		this.characterTemporalLimit = limit;
	}
	
	/**
	 * Returns the {@link Search#epistemicLimit epistemic limit} for any {@link
	 * Search searches} created by this planner. The constant {@link
	 * #UNLIMITED_DEPTH} represents no limit.
	 * 
	 * @return the epistemic limit, or {@link #UNLIMITED_DEPTH} if there is no
	 * limit
	 */
	public int getEpistemicLimit() {
		return epistemicLimit;
	}
	
	/**
	 * Sets the {@link Search#epistemicLimit epistemic limit} for any {@link
	 * Search searches} created by this planner. The constant {@link
	 * #UNLIMITED_DEPTH} represents no limit.
	 * 
	 * @param limit the epistemic limit, or {@link #UNLIMITED_DEPTH} if there
	 * should be no limit
	 */
	public void setEpistemicLimit(int limit) {
		this.epistemicLimit = limit;
	}
	
	/**
	 * Pre-processes a {@link Problem problem} in preparation for {@link
	 * #getSearch(Problem, Status) creating a search} to solve that problem.
	 * <p>
	 * By default, this method returns the problem with no modifications.
	 * 
	 * @param problem the problem to pre-process
	 * @param status a status to update during the pre-processing
	 * @return the pre-processed problem, or the original problem is not
	 * pre-processing needs to be done
	 */
	public Problem compile(Problem problem, Status status) {
		return problem;
	}
	
	/**
	 * This is the main factory method of a planner which takes as input a
	 * {@link Problem planning problem} and returns a {@link Search search
	 * object} for that problem which is configured based on this planner's
	 * current settings. This method may take a significant amount of time
	 * if the planner needs to compile the problem or any auxiliary tools for
	 * solving the problem. Before returning the search object, this method
	 * should call {@link Search#setStart(edu.uky.cs.nil.sabre.State)} and
	 * {@link Search#setGoal(edu.uky.cs.nil.sabre.Number)} appropriate default
	 * values.
	 * 
	 * @param problem the planning problem to be solved
	 * @param status a status object to update while compiling the problem and
	 * preparing the search object
	 * @return the search object
	 */
	public abstract Search<A> getSearch(Problem problem, Status status);
}