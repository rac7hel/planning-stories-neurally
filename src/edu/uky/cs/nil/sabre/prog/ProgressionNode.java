package edu.uky.cs.nil.sabre.prog;

import edu.uky.cs.nil.sabre.Character;
import edu.uky.cs.nil.sabre.State;
import edu.uky.cs.nil.sabre.comp.CompiledAction;
import edu.uky.cs.nil.sabre.comp.CompiledProblem;
import edu.uky.cs.nil.sabre.logic.Value;

/**
 * A progression node represents a node in a {@link ProgressionSpace search
 * space} and its context in a {@link ProgressionSearch progression search},
 * such as the temporal and epistemic depth at which the node exists in that
 * search. The same node in a search space might be reached at different times
 * and in different ways during different search methods. Likewise, the same
 * search might find the same node in a search space multiple times but at
 * different temporal or epistemic depths. A progresison node is a reference
 * both to the search space node and to how and when it was reached in a
 * particular search.
 * 
 * @param <N> the type of object used to represent a node in {@link
 * ProgressionSpace the search space}
 * @author Stephen G. Ware
 */
public interface ProgressionNode<N> extends State {

	/**
	 * Returns the {@link CompiledProblem problem} the search that generated
	 * this node is solving.
	 * 
	 * @return the problem being solved by the search that generated this node
	 */
	public default CompiledProblem getProblem() {
		return getSearch().problem;
	}
	
	/**
	 * Returns the {@link ProgressionSearch search} that generated this node.
	 * 
	 * @return the search that generated this node
	 */
	public ProgressionSearch getSearch();
	
	/**
	 * Returns the {@link ProgressionSpace search space} the search that
	 * generated this node is using. The {@link #getNode() search space node}
	 * associated with this progression node will be a node in that space.
	 * 
	 * @return the search space used by the search that generated this node
	 */
	@SuppressWarnings("unchecked")
	public default ProgressionSpace<N> getSpace() {
		return (ProgressionSpace<N>) getSearch().space;
	}
	
	/**
	 * Returns the {@link Character character} whose utility the search that
	 * produced this node was trying to improve when this node was generated.
	 * 
	 * @return the character whose utility the search was trying to improve when
	 * this node was generated
	 */
	public Character getCharacter();
	
	/**
	 * Returns this node's trunk, which is a {@link ProgressionSpace search
	 * space} node that represents the original action that was being explained
	 * when the search generated this node. When a {@link ProgressionSearch
	 * progression search} adds an action to a plan, it must explain that action
	 * for each of its consenting characters by creating branches for each one.
	 * A branch is the state that character believes will be the case after
	 * taking the action; the state after the original action from which the
	 * branches extend is the trunk for all of those branches. The primary
	 * search to improve the author's utility has no trunk, and this method will
	 * return null for those nodes.
	 * 
	 * @return the trunk node that the search was explaining when this node was
	 * created, or null if this node is part of the search to improve the
	 * author's utility
	 */
	public N getTrunk();
	
	/**
	 * Returns the root from which this node is a temporal descendant, which is
	 * a {@link ProgressionSpace search space} node that represents where the
	 * search that generated this node started. When a {@link ProgressionSearch
	 * progression search} adds an action to a plan, it must explain the action
	 * for each of its consenting characters by creating branches for each one.
	 * A branch starts in the state that character believes will be the case
	 * after taking the action; this starting state is called the root. The root
	 * node is one which, if explained, would mean the original {@link
	 * #getTrunk() trunk node} is also explained for one of its consenting
	 * characters.
	 * 
	 * @return the root node where the search began to explain an action for
	 * a character and which caused this node to be generated
	 */
	public N getRoot();
	
	/**
	 * Returns the {@link ProgressionSpace#getAction(Object) action} associated
	 * with this node's {@link #getNode() search space node}.
	 * 
	 * @return the action associated with this node's search space node
	 */
	public default CompiledAction getAction() {
		return getSpace().getAction(getNode());
	}
	
	/**
	 * Returns the node from the {@link ProgressionSpace search space} that this
	 * progression node is referring to. A progression node is a reference to
	 * a node in the {@link #getSearch() search's} {@link #getSpace() space}
	 * (accessed with this method), but annotated with the context in which it
	 * was generated by the search.
	 * 
	 * @return the search space node associated with this progression node
	 */
	public N getNode();
	
	/**
	 * Returns whether or not the {@link #getNode() search space node} that this
	 * progression node refers to is {@link ProgressionSpace#isExplained(Object)
	 * explained} for all the characters for which it needs to be explained.
	 * Usually, a node needs to be explained for all of the {@link
	 * CompiledAction#consenting consenting characters} of {@link #getAction()
	 * the action} that led to the state the node represents. However, there is
	 * one special case: {@link #getRoot() a root node}. A root node is created
	 * to explain one action ({@link #getTrunk() the trunk}) for one character.
	 * This means that a root node only needs to be explained for the character
	 * it was created to explained, even if the action has more than one
	 * consenting character. If this progression node is a root, this method
	 * will return true if it is explained {@link #getCharacter() for its
	 * character}, no matter how many consenting characters the action may have.
	 * 
	 * @return true if the node is explained for all its consenting characters
	 * or if the node is a root node and is explained for the character that
	 * root node was created to explain; false otherwise
	 */
	public default boolean isExplained() {
		if(getTemporalDepth() == 0)
			return isExplained(getCharacter());
		else
			return getSpace().isExplained(getNode());
	}
	
	/**
	 * Returns whether or not the {@link #getNode() search space node} that this
	 * progression node refers to is {@link
	 * ProgressionSpace#isExplained(Object, Character) explained for the given
	 * character}. In some implementations, this method will return false if
	 * the character is not a consenting character to {@link #getAction() the
	 * node's action}, even if that character would want the action to happen.
	 * 
	 * @param character the character for whom the node may be explained
	 * @return true if the node is explained for that character
	 */
	public default boolean isExplained(Character character) {
		return getSpace().isExplained(getNode(), character);
	}
	
	/**
	 * Returns the utility of a given character (or the author, if the character
	 * is null) in the state represented by this progression node's {@link
	 * #getNode() search space node}.
	 * 
	 * @param character the character whose utility is desired, or null if the
	 * author's utility is desired
	 * @return the utility of that character in that state this node represents
	 */
	public default Value getUtility(Character character) {
		if(character == null)
			return getProblem().utility.evaluate(this);
		else
			return getProblem().utilities.get(character).evaluate(this);
	}
	
	/**
	 * Returns the temporal depth at which {@link #getRoot() this node's root}
	 * started. When a branch is created to explain an action in the author's
	 * plan (that is, any node with an {@link #getEpistemicDepth() epistemic
	 * depth of 0}), that branch's root always begins at a temporal offset of 1
	 * (which represents taking the action the root is trying to explain) and a
	 * {@link #getTemporalDepth() temporal depth} of 0. When a branch is created
	 * to explain a node with an epistemic depth greater than 0, that branch's
	 * root's temporal offset will be the sum of the trunk's temporal offset
	 * and the trunk's temporal depth.
	 * <p>
	 * For example, say a branch is created to explain an action that has been
	 * added to the author's plan. The root of that branch (and all it
	 * descendants) will have an epistemic depth of 1 and a temporal offset of
	 * 1. That root will have a temporal depth of 0; its {@link
	 * ProgressionSpace#getChild(Object, CompiledAction) children} will have a
	 * temporal depth of 1; their children will have a temporal depth of 2, etc.
	 * Consider a grandchild of that root node, meaning 2 actions have been
	 * taken since the root state. The grandchild will have an epistemic depth
	 * of 1 and a temporal offset of 1 (just like all the root's descendants),
	 * but it will have a temporal depth of 2, representing the two actions. If
	 * a branch is created to explain that grandchild, the root of that branch
	 * will have an epistemic depth of 2 and a temporal offset of 3 (1 for the
	 * trunk's temporal offset and 2 for the trunk's temporal depth).
	 * <p>
	 * The sum of a node's temporal offset and temporal depth must always be
	 * less than or equal to the {@link ProgressionSearch#characterTemporalLimit
	 * search's character temporal limit}. This means that plans formed at
	 * epistemic depth 1 can have as many actions as the search's character
	 * temporal limit, but plans formed at epistemic depth 2 can have at most
	 * that many actions minus 1, and so on. Thus, a character temporal limit
	 * also imposes a de facto epistemic limit of the same depth.
	 * 
	 * @return the temporal depth at which this node's root started
	 */
	public int getTemporalOffset();
	
	/**
	 * Returns the number of actions that have been taken since {@link
	 * #getRoot() this node's root state}. See {@link #getTemporalOffset()} for
	 * a description of the distinction between temporal offset and temporal
	 * depth.
	 * 
	 * @return the number of actions that have been taken since this node's root
	 * state
	 */
	public int getTemporalDepth();
	
	/**
	 * Returns the depth of nested theory of mind (what one {@link Character
	 * character} believes another character believes, and so on) at which this
	 * node was created. All nodes have the same epistemic depth as their {@link
	 * #getRoot() root}, which is always 1 higher than their {@link #getTrunk()
	 * trunk}. A node will only be visited if its epistemic depth is less than
	 * or equal to {@link ProgressionSearch#epistemicLimit the search's
	 * epistemic limit}.
	 * 
	 * @return the depth of theory of mind at which this node was created
	 */
	public int getEpistemicDepth();
}